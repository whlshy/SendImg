import{r as k,b as Y}from"./react-DXRKQaLJ.js";const g={};let Z=0;function ht(t,d){const l=`atom${++Z}`,h={toString:()=>l};return typeof t=="function"?h.read=t:(h.init=t,h.read=Q,h.write=tt),d&&(h.write=d),h}function Q(t){return t(this)}function tt(t,d,l){return d(this,typeof l=="function"?l(t(this)):l)}const F=(t,d)=>t.unstable_is?t.unstable_is(d):d===t,L=t=>"init"in t,W=t=>!!t.write,V=new WeakMap,et=(t,d)=>{V.set(t,d),t.catch(()=>{}).finally(()=>V.delete(t))},x=(t,d)=>{const l=V.get(t);l&&(V.delete(t),l(d))},B=(t,d)=>{t.status="fulfilled",t.value=d},G=(t,d)=>{t.status="rejected",t.reason=d},nt=t=>typeof(t==null?void 0:t.then)=="function",M=(t,d)=>!!t&&"v"in t&&"v"in d&&Object.is(t.v,d.v),H=(t,d)=>!!t&&"e"in t&&"e"in d&&Object.is(t.e,d.e),P=t=>!!t&&"v"in t&&t.v instanceof Promise,ot=(t,d)=>"v"in t&&"v"in d&&t.v.orig&&t.v.orig===d.v.orig,R=t=>{if("e"in t)throw t.e;return t.v},st=()=>{const t=new WeakMap,d=new WeakMap,l=[],h=new WeakMap;let w,E;(g?"production":void 0)!=="production"&&(w=new Set,E=new Set);const _=e=>t.get(e),A=(e,o)=>{o.d.forEach((u,r)=>{if(!h.has(r)){const n=_(r);h.set(r,[n,new Set]),n&&A(r,n)}h.get(r)[1].add(e)})},C=(e,o)=>{var u;(g?"production":void 0)!=="production"&&Object.freeze(o);const r=_(e);if(t.set(e,o),(u=l[l.length-1])==null||u.add(e),h.has(e)||(h.set(e,[r,new Set]),A(e,o)),P(r)){const n="v"in o?o.v instanceof Promise?o.v:Promise.resolve(o.v):Promise.reject(o.e);r.v!==n&&x(r.v,n)}},S=(e,o,u,r)=>{const n=new Map(r?o.d:null);let s=!1;u.forEach((i,c)=>{!i&&F(e,c)&&(i=o),i?(n.set(c,i),o.d.get(c)!==i&&(s=!0)):(g?"production":void 0)!=="production"&&console.warn("[Bug] atom state not found")}),(s||o.d.size!==n.size)&&(o.d=n)},b=(e,o,u,r)=>{const n=_(e),s={d:(n==null?void 0:n.d)||new Map,v:o};if(u&&S(e,s,u,r),M(n,s)&&n.d===s.d)return n;if(P(n)&&P(s)&&ot(n,s)){if(n.d===s.d)return n;s.v=n.v}return C(e,s),s},D=(e,o,u,r)=>{if(nt(o)){let n;const s=()=>{const c=_(e);if(!P(c)||c.v!==i)return;const a=b(e,i,u);d.has(e)&&c.d!==a.d&&q(e,a,c.d)},i=new Promise((c,a)=>{let f=!1;o.then(v=>{f||(f=!0,B(i,v),c(v),s())},v=>{f||(f=!0,G(i,v),a(v),s())}),n=v=>{f||(f=!0,v.then(p=>B(i,p),p=>G(i,p)),c(v))}});return i.orig=o,i.status="pending",et(i,c=>{c&&n(c),r==null||r()}),b(e,i,u,!0)}return b(e,o,u)},N=(e,o,u)=>{const r=_(e),n={d:(r==null?void 0:r.d)||new Map,e:o};return u&&S(e,n,u),H(r,n)&&r.d===n.d?r:(C(e,n),n)},y=(e,o)=>{const u=_(e);if(!(o!=null&&o(e))&&u&&(d.has(e)||Array.from(u.d).every(([f,v])=>{if(f===e)return!0;const p=y(f,o);return p===v||M(p,v)})))return u;const r=new Map;let n=!0;const s=f=>{if(F(e,f)){const p=_(f);if(p)return r.set(f,p),R(p);if(L(f))return r.set(f,void 0),f.init;throw new Error("no atom init")}const v=y(f,o);return r.set(f,v),R(v)};let i,c;const a={get signal(){return i||(i=new AbortController),i.signal},get setSelf(){return(g?"production":void 0)!=="production"&&!W(e)&&console.warn("setSelf function cannot be used with read-only atom"),!c&&W(e)&&(c=(...f)=>{if((g?"production":void 0)!=="production"&&n&&console.warn("setSelf function cannot be called in sync"),!n)return j(e,...f)}),c}};try{const f=e.read(s,a);return D(e,f,r,()=>i==null?void 0:i.abort())}catch(f){return N(e,f,r)}finally{n=!1}},m=e=>R(y(e)),I=e=>{const o=c=>{var a,f;const v=new Set((a=d.get(c))==null?void 0:a.t);return(f=h.get(c))==null||f[1].forEach(p=>{v.add(p)}),v},u=new Array,r=new Set,n=c=>{if(!r.has(c)){r.add(c);for(const a of o(c))c!==a&&n(a);u.push(c)}};n(e);const s=new Set([e]),i=c=>r.has(c);for(let c=u.length-1;c>=0;--c){const a=u[c],f=_(a);if(!f)continue;let v=!1;for(const p of f.d.keys())if(p!==a&&s.has(p)){v=!0;break}if(v){const p=y(a,i);A(a,p),M(f,p)||s.add(a)}r.delete(a)}},$=(e,...o)=>{const u=s=>R(y(s)),r=(s,...i)=>{const c=l.length>0;c||l.push(new Set([s]));let a;if(F(e,s)){if(!L(s))throw new Error("atom not writable");const f=_(s),v=D(s,i[0]);M(f,v)||I(s)}else a=$(s,...i);if(!c){const f=O(l.pop());(g?"production":void 0)!=="production"&&w.forEach(v=>v({type:"async-write",flushed:f}))}return a};return e.write(u,r,...o)},j=(e,...o)=>{l.push(new Set([e]));const u=$(e,...o),r=O(l.pop());return(g?"production":void 0)!=="production"&&w.forEach(n=>n({type:"write",flushed:r})),u},U=(e,o,u)=>{var r;const n=d.get(e);if(n)return o&&n.t.add(o),n;const s=u||[];(r=_(e))==null||r.d.forEach((c,a)=>{a!==e&&U(a,e,s)}),y(e);const i={t:new Set(o&&[o]),l:new Set};if(d.set(e,i),(g?"production":void 0)!=="production"&&E.add(e),W(e)&&e.onMount){const{onMount:c}=e;s.push(()=>{const a=c((...f)=>j(e,...f));a&&(i.u=a)})}return u||s.forEach(c=>c()),i},X=(e,o)=>!o.l.size&&(!o.t.size||o.t.size===1&&o.t.has(e)),z=(e,o)=>{if(!X(e,o))return;const u=o.u;u&&u(),d.delete(e),(g?"production":void 0)!=="production"&&E.delete(e);const r=_(e);r?(P(r)&&x(r.v),r.d.forEach((n,s)=>{if(s!==e){const i=d.get(s);i&&(i.t.delete(e),z(s,i))}})):(g?"production":void 0)!=="production"&&console.warn("[Bug] could not find atom state to unmount",e)},q=(e,o,u)=>{const r=new Set(o.d.keys()),n=new Set;u==null||u.forEach((s,i)=>{if(r.has(i)){r.delete(i);return}n.add(i);const c=d.get(i);c&&c.t.delete(e)}),r.forEach(s=>{U(s,e)}),n.forEach(s=>{const i=d.get(s);i&&z(s,i)})},O=e=>{let o;(g?"production":void 0)!=="production"&&(o=new Set);const u=[],r=n=>{var s;if(!h.has(n))return;const[i,c]=h.get(n);h.delete(n),u.push([n,i]),c.forEach(r),(s=_(n))==null||s.d.forEach((a,f)=>r(f))};if(e.forEach(r),u.forEach(([n,s])=>{const i=_(n);if(!i){(g?"production":void 0)!=="production"&&console.warn("[Bug] no atom state to flush");return}if(i!==s){const c=d.get(n);c&&i.d!==(s==null?void 0:s.d)&&q(n,i,s==null?void 0:s.d),c&&!(!P(s)&&(M(s,i)||H(s,i)))&&(c.l.forEach(a=>a()),(g?"production":void 0)!=="production"&&o.add(n))}}),(g?"production":void 0)!=="production")return o},J=(e,o)=>{const u=U(e),r=O([e]),n=u.l;return n.add(o),(g?"production":void 0)!=="production"&&w.forEach(s=>s({type:"sub",flushed:r})),()=>{n.delete(o),z(e,u),(g?"production":void 0)!=="production"&&w.forEach(s=>s({type:"unsub"}))}};return(g?"production":void 0)!=="production"?{get:m,set:j,sub:J,dev_subscribe_store:e=>(w.add(e),()=>{w.delete(e)}),dev_get_mounted_atoms:()=>E.values(),dev_get_atom_state:e=>t.get(e),dev_get_mounted:e=>d.get(e),dev_restore_atoms:e=>{l.push(new Set);for(const[u,r]of e)L(u)&&(D(u,r),I(u));const o=O(l.pop());w.forEach(u=>u({type:"restore",flushed:o}))}}:{get:m,set:j,sub:J}};let T;const rt=()=>(T||(T=st(),(g?"production":void 0)!=="production"&&(globalThis.__JOTAI_DEFAULT_STORE__||(globalThis.__JOTAI_DEFAULT_STORE__=T),globalThis.__JOTAI_DEFAULT_STORE__!==T&&console.warn("Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044"))),T),it=rt,ct={},ut=k.createContext(void 0),K=t=>k.useContext(ut)||it(),dt=t=>typeof(t==null?void 0:t.then)=="function",ft=Y.use||(t=>{if(t.status==="pending")throw t;if(t.status==="fulfilled")return t.value;throw t.status==="rejected"?t.reason:(t.status="pending",t.then(d=>{t.status="fulfilled",t.value=d},d=>{t.status="rejected",t.reason=d}),t)});function lt(t,d){const l=K(),[[h,w,E],_]=k.useReducer(S=>{const b=l.get(t);return Object.is(S[0],b)&&S[1]===l&&S[2]===t?S:[b,l,t]},void 0,()=>[l.get(t),l,t]);let A=h;return(w!==l||E!==t)&&(_(),A=l.get(t)),k.useEffect(()=>{const S=l.sub(t,()=>{_()});return _(),S},[l,t,void 0]),k.useDebugValue(A),dt(A)?ft(A):A}function at(t,d){const l=K();return k.useCallback((...w)=>{if((ct?"production":void 0)!=="production"&&!("write"in t))throw new Error("not writable atom");return l.set(t,...w)},[l,t])}function pt(t,d){return[lt(t),at(t)]}export{ht as a,lt as b,pt as u};
